TGL -- Text Generation Language

Dependencies:
  Nothing beyond the standard UNIX headers.
Building:
  ./configure
  make
Installing:
  make install
(or "sudo make install").

---

TGL is a simple, terse system for generating text from an input string. It is
intended to be used as a sort of macro system with a real editor (eg, with
shell-command-on-region in Emacs) rather than a real programming language. As
such, it is optimised ONLY for terseness, with no focus on readability at all.

STATUS

TGL is not yet complete. The following are not yet supported:
+ Command-line arguments
+ Context (@ commands)
+ History (h command)
+ User library (v, V commands)

BASICS

Every value in TGL is a string. These strings may be pushed onto/popped from a
single stack, stored into registers (one for every printable ASCII character),
interpreted as integers, and executed as code.

Like in TECO, every TGL command is a single character, and each character in
TGL code is executed in sequence. Some commands will modify the input pointer,
giving the illusion of deeper structure. Most commands operate only on strings
at the top of the primary stack. Whitespace is ignored on execution.

Integers follow the format (not case-sensitive):
  [+-]?([0-9]+|0x[0-9A-F]+|0o[0-7]+|0b[01]+)

A boolean is true if it is a non-empty string which is not equal to any
representation of integer zero.

CONTEXT

The interpreter may be run with a given context (if none is given, it is the
empty string). Context can be used for conditional inclusion in the user's
library of macros (see "D", defun-contextual).

COMMANDS

Built-in commands are:
  Q...  (long-command: ??? -> ???)
    Skips input characters up to the next whitespace. The skipped characters
    are interpreted as a long command name, which is then executed. Execution
    then continues with the first whitespace character.
  .     (print: string -> ())
    The string at the top of the stack is printed to stdout.
  'C    (char: () -> string)
    The instruction pointer is advanced one space, and the character C is
    pushed onto the stack as a one-character string.
    Note that, since TGL is not Unicode-aware, non-ASCII characters will not
    work as expected with this command. For example, in UTF-8, the code
      'ÃŸ
    will not push a string containing a single Eszett, but rather the byte C3;
    the interpreter will then try to execute a command corresponding to 0x9F,
    which will probably fail.
    For unicode characters, using double-quotes (see below) will work, in that
    the string will contain both bytes encoding the character.
  :     (dupe: item -> item item)
    The top item on the stack is duplicated.
  ;     (drop: item -> ())
    The top item on the stack is popped and discarded.
  x     (swap: a b -> b a)
    The top two items on the stack are swapped.
  c     (concat: a b -> ab)
    Pops the top two elements from the stack and pushed their concatenation.
  l     (length: string -> length)
    Pops a string and pushes the integer length of the string.
  C     (char-at: string index -> char)
    Pops a string and an index, and pushes the character at the given index.
  s     (substr: string from to -> substr)
    Pops a string and two indices, and returns a substring between the two
    (including from excluding to).
  S     (suffix: string from -> substr)
    Like substr, but assumes to is the end of the string.
  m     (map: string [from to ...]{n} n -> string)
    Maps each occurance of from to to in the string, left to right. Replaced
    text is not subject to replacement.
  +     (add: a b -> (a+b))
  -     (sub: a b -> (a-b))
  *     (mul: a b -> (a*b))
  /     (div: a b -> (a/b))
  %     (mod: a b -> (a-a/b))
    The two top stack elements are popped and interpreted as integers, and the
    result of the respective arithmetic operation is pushed onto the stack.
  =     (equal: a b -> (a==b? 1:0))
  !     (not-equal: a b -> (a!=b? 1:0))
    The two top stack elements are popped, and the result of the (string)
    comparison is pushed.
  <     (less: a b -> (a<b? 1:0))
  >     (greater: a + -> (a>b? 1:0))
    The two top stack elements are popped and interpreted as integers, and the
    result of the comparison is pushed.
  {     (string-less: a b -> (a<b? 1:0))
  }     (string-greater: a b -> (a>b? 1:0))
    Like < and >, but perform string comparisons.
  &     (and: a b -> (a && b))
  |     (or:  a b -> (a || b))
  ^     (xor: a b -> (a ^  b))
    Pops the two top elements from the stack, and pushes the result of the
    given logical operation to the stack. No short-circuiting occurs.
  ~     (not: a -> !a)
    Pops an element from the top of the stack, and pushes its logical negation.
  (...) (code: () -> string)
    The literal string between the (balanced) parentheses is pushed. Execution
    continues after the closing parenthesis.
  i     (if: cond then else -> ???)
    If cond (value) is true, execute then; otherwise, execute else.
  I     (if-short: cond then -> ???)
    Like if, but do nothing if cond false.
  w     (while: cond code -> ???)
    Executes cond. If the top of the stack (popped) is true, execute code and
    repeat.
  W     (short-while: code -> ???)
    Evaluate code. If the top of the stack (popped) is true, repeat.
  f     (for: reg from to body -> ???)
    Execute body with reg set to increasing values starting at from and ending
    (but not including) to.
  F     (short-for: to body -> ???)
    Like for, but assumes the register is "i" and from is "0".
  d     (defun: name body -> ())
    Defines the command of the given name. If it already exists, it is replaced.
    It may be more than one character long. After running this, the command can
    be invoked normally.
  D     (defun-contextual: name body -> ())
    Like defun, but does nothing if the current context is inactive.
  X     (eval: code -> ???)
    Evaluates code.
  rC    (read: () -> string)
    Pushes the contents of register C to the stack.
  RC    (write: string -> ())
    Pops the top stack value into register C.
  p     (stash: () -> <undefined>)
    Pushes all registers onto the stack. The method in which this is done is
    undefined.
  P     (retrieve: <undefined> -> ())
    Pops all registers from the stack, undoing a "p". The method in which this
    is is done is undefined.
  z     (stash-retrieve: code -> code)
    Places a "p" at the beginning of code, and a "P" at the end.
  "..." (string: ??? -> string)
    Pushes an interpolated string to the stack. The following characters are
    considered special:
      "        Terminates the string; execution continues after the ".
      \        Evaluates the \ command and interpolates the result.
      $        Reads the character after the $ and splices the value of that
               register into the string.
      %        Pops a value from the stack and splices the value into the
               string.
      `        Expands to the whitespace encountered before the first real
               command in the primary input string.
  \...  (escape: () -> string)
    Pushes a single character corresponding to the full escape sequence:
      \a       BEL
      \b       Backspace
      \e       ESC
      \f       FF
      \n       LF
      \r       CR
      \t       HT
      \v       VT
      \x##     The character ## (hexadecimal)
    The following sequences result in simply the character being escaped:
      \" \\ \$ \% \` \'
  #     (number: () -> integer)
    Skips the #, then reads an optional sign followed by digits and pushes the
    resulting integer.
  0,1,2,3,4,5,6,7,8,9
    Like #, but does not skip the first character.
  ?     (rand: () -> integer)
    Returns a random integer between 0 and 65535, inclusive.
  @C... (context: () -> () or () -> result)
    Alters the current context. The first character after the @ indicates how
    to affect the context, and the characters afterward up to but not including
    the next whitespace indicate what to match. Legal values for C are:
      =  Set context activeness to the result of the match
      !  Set context activeness to the negation of the result
      &  Deactivate context if the result is negative
      |  Activate context if the result is positive
      ^  Deactivate context if the result is positive
      v  Activate context if the result is negative.
    Other specifiers will query the context:
      @? Pushes a boolean indicating whether the context is active.
      @s Pushes the context string itself.
      @e Pushes the filename extension of the context string, including the ".".
  H     (suppress-history: () -> ())
    If executed, the input will not be added to the user's TGL history.
  h     (history-access: [off] -> ())
    Expends to the history at the given offset. If the stack is empty when
    trying to read off, assume 0. Each usage of h increments a counter which is
    implicitly added to whatever offset is specified; the increment occurs
    after the command has otherwise completed.
  v     (save-code: name code -> ???)
    Creates a defun statement with the given name and code, executes it, then
    appends it to the user's library.
  VC    (save-code-contextual: code -> ???)
    Like v, but the character C is read, which must be s or e. The written code
    is prefixed by context statements to limit any definition to this context
    (s) or file type (e).

REGISTER PERSISTENCE

TGL can save the values within registers across invocations. By default, these
data are stored in ~/.tgl_registers. Whenever TGL exits successfully, the
status of these registers is written to this file. The contents of this file is
not defined and is architecture- (and theoretically compiler-) specific.

HISTORY

By default, each string of commands successfully executed is added to a command
history. The history is stored in registers 0 through 31, inclusive (that is,
the registers corresponding to the ASCII control characters), where register 0
contains the most recently-executed command. The H command can be used to
suppress history logging, and the h command will access it. Commands whose only
non-whitespace contents are "hX" are implicitly execluded from history.

EXAMPLES

Hello world:
  "Hello, world!".

99 Bottles of Beer:
  99Rc"bottles"RBrcRC(rc#-1>)(
  "$C $B of beer on the wall\n$C $B of beer\n".
  rc1-Rc
  rc1=("bottle")("bottles")iRBrc0=("No more")(rc)iRC
  rc#-1=(
    "Go to the store, buy some more\n99 bottles of beer on the wall\n"
  )(
    "Take one down, pass it around\n$C $B of beer on the wall\n"
  )i.)w

Quickly generate case statements for each digit:
  10("`case '$i':\n".)F

Save the previous to a language-specific macro:
  "nc"hzVe

Resusing the new macro:
  Qnc

Creating a macro to place strings into C-strings (quoting and escaping):
  @=.h @|.c
  "cq" (\\(\\)\n(\n)\r(\r)\t(\t)\"(\")\e(\e)\f(\f)\v(\v)8m"\"%\"") D
Note that the contexts will match ANY context containing ".h" or ".c" anywhere,
not just ending in those names.