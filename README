TGL -- Text Generation Language

Dependencies:
  Nothing beyond the standard UNIX headers.
Building:
  ./configure
  make
Installing:
  make install
(or "sudo make install").

---

TGL is a simple, terse system for generating text from an input string. It is
intended to be used as a sort of macro system with a real editor (eg, with
shell-command-on-region in Emacs) rather than a real programming language. As
such, it is optimised ONLY for terseness, with no focus on readability at all.

USAGE
tgl [options] [infile]
Options:
  -l, --library file                    Use the given file as the user library
  -r, --register-persistence file       Use the given file for register
                                        persistence
  -c, --context name                    Specify the current context
  -h, --help                            Display usage information

If infile is not specified, read program from stdin.

BASICS

Every value in TGL is a string. These strings may be pushed onto/popped from a
single stack, stored into registers (one for every printable ASCII character),
interpreted as integers, and executed as code.

Like in TECO, every TGL command is a single character, and each character in
TGL code is executed in sequence. Some commands will modify the input pointer,
giving the illusion of deeper structure. Most commands operate only on strings
at the top of the primary stack. Whitespace is ignored on execution.

Integers follow the format (not case-sensitive):
  [+-]?([0-9]+|0x[0-9A-F]+|0o[0-7]+|0b[01]+)

A boolean is true if it is a non-empty string which is not equal to any
representation of integer zero.

CONTEXT

The interpreter may be run with a given context (if none is given, it is the
empty string). Context can be used for conditional inclusion in the user's
library of macros (see "D", defun-contextual).

COMMANDS

Built-in commands are:
  Q...  (long-command: ??? -> ???)
    Skips input characters up to the next whitespace. The skipped characters
    are interpreted as a long command name, which is then executed. Execution
    then continues with the first whitespace character.
  .     (print: string -> ())
    The string at the top of the stack is printed to stdout.
  'C    (char: () -> string)
    The instruction pointer is advanced one space, and the character C is
    pushed onto the stack as a one-character string.
    Note that, since TGL is not Unicode-aware, non-ASCII characters will not
    work as expected with this command. For example, in UTF-8, the code
      'ÃŸ
    will not push a string containing a single Eszett, but rather the byte C3;
    the interpreter will then try to execute a command corresponding to 0x9F,
    which will probably fail.
    For unicode characters, using double-quotes (see below) will work, in that
    the string will contain both bytes encoding the character.
  :     (dupe: item -> item item)
    The top item on the stack is duplicated.
  ;     (drop: item -> ())
    The top item on the stack is popped and discarded.
  x     (swap: a b -> b a)
    The top two items on the stack are swapped.
  c     (concat: a b -> ab)
    Pops the top two elements from the stack and pushed their concatenation.
  l     (length: string -> length)
    Pops a string and pushes the integer length of the string.
  C     (char-at: string index -> char)
    Pops a string and an index, and pushes the character at the given index.
  s     (substr: string from to -> substr)
    Pops a string and two indices, and returns a substring between the two
    (including from excluding to).
  S     (suffix: string from -> substr)
    Like substr, but assumes to is the end of the string.
  m     (map: string [from to ...]{n} n -> string)
    Maps each occurance of from to to in the string, left to right. Replaced
    text is not subject to replacement.
  +     (add: a b -> (a+b))
  -     (sub: a b -> (a-b))
  *     (mul: a b -> (a*b))
  /     (div: a b -> (a/b))
  %     (mod: a b -> (a-a/b))
    The two top stack elements are popped and interpreted as integers, and the
    result of the respective arithmetic operation is pushed onto the stack.
  =     (equal: a b -> (a==b? 1:0))
  !     (not-equal: a b -> (a!=b? 1:0))
    The two top stack elements are popped, and the result of the (string)
    comparison is pushed.
  <     (less: a b -> (a<b? 1:0))
  >     (greater: a + -> (a>b? 1:0))
    The two top stack elements are popped and interpreted as integers, and the
    result of the comparison is pushed.
  {     (string-less: a b -> (a<b? 1:0))
  }     (string-greater: a b -> (a>b? 1:0))
    Like < and >, but perform string comparisons.
  &     (and: a b -> (a && b))
  |     (or:  a b -> (a || b))
  ^     (xor: a b -> (a ^  b))
    Pops the two top elements from the stack, and pushes the result of the
    given logical operation to the stack. No short-circuiting occurs.
  ~     (not: a -> !a)
    Pops an element from the top of the stack, and pushes its logical negation.
  (...) (code: () -> string)
    The literal string between the (balanced) parentheses is pushed. Execution
    continues after the closing parenthesis.
  i     (if: cond then else -> ???)
    If cond (value) is true, execute then; otherwise, execute else.
  I     (if-short: cond then -> ???)
    Like if, but do nothing if cond false.
  w     (while: cond code -> ???)
    Executes cond. If the top of the stack (popped) is true, execute code and
    repeat.
  W     (short-while: code -> ???)
    Evaluate code. If the top of the stack (popped) is true, repeat.
  f     (for: reg from to body -> ???)
    Execute body with reg set to increasing values starting at from and ending
    (but not including) to.
  F     (short-for: to body -> ???)
    Like for, but assumes the register is "i" and from is "0".
  e     (each: string reg body -> ???)
    Executes body with reg set to each character in the given string.
  d     (defun: name body -> ())
    Defines the command of the given name. If it already exists, it is replaced.
    It may be more than one character long. After running this, the command can
    be invoked normally.
  D     (defun-contextual: name body -> ())
    Like defun, but does nothing if the current context is inactive.
  X     (eval: code -> ???)
    Evaluates code.
  rC    (read: () -> string)
    Pushes the contents of register C to the stack.
  RC    (write: string -> ())
    Pops the top stack value into register C.
  p     (stash: () -> <undefined>)
    Pushes all registers onto a stack independent of the main one.
  P     (retrieve: <undefined> -> ())
    Pops all registers from the stack used by p, undoing the effect of that
    command.
  z     (stash-retrieve: code -> code)
    Places a "p" at the beginning of code, and a "P" at the end.
  "..." (string: ??? -> string)
    Pushes an interpolated string to the stack. The following characters are
    considered special:
      "        Terminates the string; execution continues after the ".
      \        Evaluates the \ command and interpolates the result.
      $        Reads the character after the $ and splices the value of that
               register into the string.
      %        Pops a value from the stack and splices the value into the
               string.
      `        Expands to the whitespace encountered before the first real
               command in the primary input string.
  \...  (escape: () -> string)
    Pushes a single character corresponding to the full escape sequence:
      \a       BEL
      \b       Backspace
      \e       ESC
      \f       FF
      \n       LF
      \r       CR
      \t       HT
      \v       VT
      \x##     The character ## (hexadecimal)
    The following sequences result in simply the character being escaped:
      \" \\ \$ \% \` \'
    The following do nothing (no string is pushed); they are intended for
    manual balancing:
      \( \) \[ \] \{ \} \< \>
  #     (number: () -> integer)
    Skips the #, then reads an optional sign followed by digits and pushes the
    resulting integer.
  0,1,2,3,4,5,6,7,8,9
    Like #, but does not skip the first character.
  ?     (rand: () -> integer)
    Returns a random integer between 0 and 65535, inclusive.
  @C... (context: () -> () or () -> result)
    Alters the current context. The first character after the @ indicates how
    to affect the context, and the characters afterward up to but not including
    the next whitespace indicate what to match. "Match" indicates that the
    context matches the glob defined by the string (see fnmatch(3)). Legal
    values for C are:
      =  Set context activeness to the result of the match
      !  Set context activeness to the negation of the result
      &  Deactivate context if the result is negative
      |  Activate context if the result is positive
      ^  Deactivate context if the result is positive
      v  Activate context if the result is negative.
    Other specifiers will query the context:
      @? Pushes a boolean indicating whether the context is active.
      @s Pushes the context string itself.
      @e Pushes the filename extension of the context string, including the ".".
  H     (suppress-history: () -> ())
    If executed, the input will not be added to the user's TGL history.
  h     (history-access: [off] -> ())
    Expends to the history at the given offset. If the stack is empty when
    trying to read off, assume 0. Each usage of h increments a counter which is
    implicitly added to whatever offset is specified; the increment occurs
    after the command has otherwise completed.
  v     (save-code: name code -> ???)
    Creates a defun statement with the given name and code, executes it, then
    appends it to the user's library.
  VC    (save-code-contextual: code -> ???)
    Like v, but the character C is read, which must be s or e. The written code
    is prefixed by context statements to limit any definition to this context
    (s) or file type (e).
  ,...  (data-payload: varies)
    Prefix for all data-payload commands. See the DATA PAYLOAD section for
    details.

REGISTER PERSISTENCE

TGL can save the values within registers across invocations. By default, these
data are stored in ~/.tgl_registers. Whenever TGL exits successfully, the
status of these registers is written to this file. The contents of this file is
not defined and is architecture- (and theoretically compiler-) specific.

HISTORY

By default, each string of commands successfully executed is added to a command
history. The history is stored in registers 0 through 31, inclusive (that is,
the registers corresponding to the ASCII control characters), where register 0
contains the most recently-executed command. The H command can be used to
suppress history logging, and the h command will access it. Commands whose only
non-whitespace contents are "hX" are implicitly execluded from history.

USER LIBRARY

Before executing primary input, TGL will first read in the user library, by
default located at ~/.tgl. This file is interpreted in the same manner as
normal input. The stack is cleared after reading it, and the history offset
reset to zero.

Any error that occurs while parsing the user library is ignored, though the
normal diagnostics are displayed.

Commands that append to the library surround the appended code with a line feed
character on either side, and include a "comment" indicating when the insertion
took place.

PAYLOAD DATA

(NOTE: This is not yet implemented!)

In some cases, it is desirable to take data from a structured source, either
embedded in the script itself, or extracted from an external source. The ,
command provides functionality to access and manipulate this payload data.

Most commonly, one includes payload data within the script itself. Usually,
payload data starts after the text ",$", though the delimiter can be
changed. By passing the -p (or --prefix-payload) flag, it is also possible to
include a payload at the beginning of input. In this case, code is considered
to start after the first ",$" (though initial whitespace still counts within
the payload). Multiple dollar-signs can be used to include the ",$" within the
payload; the first occurance that has the greatest number of dollar-signs is
used to separate the payload and the code.

The first occurrance of a payload-data command which requires access to the
payload will search for the start-of-payload delimiter (default ",$") in the
code if no payload is already present.

Payload commands:
  ,$    (payload-start: () -> ())
    Moves the instruction pointer to the end of the current code.
  ,c    (payload-curr: () -> elt)
    Pushes the string corresponding to the first element of the current payload
    data onto the stack.
  ,,    (payload-next: () -> ())
    Deletes the first element of the current payload data.
  ,;    (payload-next-kv: () -> ())
    Deletes the first two elements of the current payload data.
  ,.    (payload-print: () -> ())
    Prints the first element of the current payload data, then removes it.
    Equivalent to ,c.,,
  ,:    (payload-print-kv: () -> ())
    Prints the first two elements of the current payload data, separated by the
    current output-kv-delimiter, then deletes them.
    Equivalent to ,.,?ok.,.
  ,r    (payload-read: () -> payload)
    Pushes the current payload data onto the stack.
  ,R    (payload-write: payload -> ())
    Pops the top of the stack into the current payload, discarding its original
    contents.
  ,h    (payload-length-bytes: () -> byte-count)
    Pushes an integer indicating how many bytes are left in the current payload
    data. No values remain if and only if this command returns zero. (Thus the
    mnemonic Has-more.)
  ,eR   (payload-each: body -> ???)
    With R set to each consecutive value within the payload, execute body.
    Equivalent to
      (,h)(,cRR,, body)w
  ,EKV  (payload-each-kv: body -> ??)
    With K set to each consecutive key, and V to each value, execute body.
    Equivalent to
      (,h)(,cRK,,,cRV,, body)w
  ,i    (payload-datum-at-index: index -> value)
    Pushes the payload element at the given index.
    Note that this command has O(n) complexity.
  ,I    (payload-num-indices: () -> count)
    Returns the number of elements in the current payload.
    Note that this command has O(n) complexity.
  ,k    (payload-datum-at-key: key -> value)
    Pushes the first payload value element with the given key.
    Note that this command has O(n) complexity.
  ,/VV  (payload-set-property: value -> ())
    Configures the given property to the given string. Legal values for VV:
      ps (payload-start, default ",$")
        The delimiter that separates code from payload.
      vd (value-delimiter, default nonrepresentable)
        The delimiter that separates values (or keys and values) within the
        payload. Default is described by ,s.
      ok (output-kv-delimiter, default ",")
        The delimiter to use when outputting key-value pairs. Default is ",".
      b(, b[, b{, b<    (balance-paren)
        May be set to any legal boolean. When true, delimiters do not split
        values when the given paren type is unbalanced. When false, the
        characters have no special meaning. Default is true for all but angles
        (b<).
      t(, t[, t{, t<,   (trim-paren)
        May be set to any legal boolean. When true, matching outer parens of
        the given type are stripped (only one level) implicitly. Default is
        true for all but angles (t<).
      ts (trim-space)
        Like the above, but trims all whitespace. Default true.
  ,?VV  (payload-get-property: () -> value)
    Pushes the current value of property VV (see above).
  ,s    (payload-space-delimited: () -> ())
    Sets payload to be delimited by whitespace of any kind, combination, and
    amount. Resets balance and trim properties to defaults. If this mode is in
    use when payload is first extracted (or with ,!), leading space in the
    payload is skipped. This can be indicated in generic properties with the
    special string "ws".
  ,0    (payload-nul-delimited: () -> ())
    Sets the NUL character as the sole delimiter for payload data, and sets all
    balance and trim properties to false.
  ,l    (payload-line-delimited: () -> ())
    Sets the "\n", "\r", and "\r\n" as value delimiters, and sets all
    paren-related balancing and trimming to false. If this mode is in use when
    the payload is first extracted (or with ,!), leading line feeds in the
    payload are skipped. This can be indicated in generic properties with the
    special string "lf".
  ,f    (payload-from-file: filename -> ())
    Sets the payload data to the contents of the given file.
  ,F    (payload-from-glob: glob -> ())
    Sets the payload data to a NUL-delimited list of files matching the given
    glob, and implicitly executes ",0".
  ,!    (payload-from-code: () -> ())
    Sets the payload data to that executed from the global-level code. This is
    done automatically if the payload data is executed when none has been
    extracted, though it can be used to reset the data to this.

EXAMPLES

Hello world:
  "Hello, world!".

99 Bottles of Beer:
  99Rc"bottles"RBrcRC(rc#-1>)(
  "$C $B of beer on the wall\n$C $B of beer\n".
  rc1-Rc
  rc1=("bottle")("bottles")iRBrc0=("No more")(rc)iRC
  rc#-1=(
    "Go to the store, buy some more\n99 bottles of beer on the wall\n"
  )(
    "Take one down, pass it around\n$C $B of beer on the wall\n"
  )i.)w

Quickly generate case statements for each digit:
  10("`case '$i':\n".)F

Save the previous to a language-specific macro:
  "nc"0hzVe

Resusing the new macro:
  Qnc

Creating a macro to place strings into C-strings (quoting and escaping):
  @=*.h @|*.c
  "cq" (\\(\\)\n(\n)\r(\r)\t(\t)\"(\")\e(\e)\f(\f)\v(\v)8m"\"%\"") D
